#include "Arduino.h"
#include "MotorController.h"
#include "MotionController.h"

#define MOTOR_LEFT_ENCODER_A_PIN 17
#define MOTOR_LEFT_ENCODER_B_PIN 16
#define MOTOR_RIGHT_ENCODER_A_PIN 15
#define MOTOR_RIGHT_ENCODER_B_PIN 14

// int maxRPM = 160;
// int encoderCPR = 48;
// float gearRatio = 46.85;
// float wheelBase = 16.75; // cm
// float wheelBaseCircumference = PI * wheelBase; // cm
// float wheelCircumference = PI * 6; // cm
// float numTicksPerRevolution = gearRatio * encoderCPR; // (double encoder, double edge)
// float distancePerTick = wheelCircumference / numTicksPerRevolution; // cm
// int maxTickSpeed = (int) ((maxRPM * numTicksPerRevolution) / 60) / (1000 / loopTime); // ticks/loopTime
// int minSpeed = 2; // cm/s
// int maxSpeed = 50; // cm/s

/**
 * MotionController
 * @param loopTime
 */
MotionController::MotionController(MotorController leftMotorController, MotorController rightMotorController, int loopTime) :
  _leftMotorController(leftMotorController),
  _rightMotorController(rightMotorController)
{
  _leftMotorDirection = 0;
  _rightMotorDirection = 0;
  _targetDistance = 0;
  _targetCommand = 0;
  _accTicks = 0;

  // _wheelBaseCircumference = PI * wheelBase; // cm
  // _wheelCircumference = PI * 6; // cm
  // _numTicksPerRevolution = gearRatio * encoderCPR; // (double encoder, double edge)
  // _distancePerTick = _wheelCircumference / _numTicksPerRevolution; // cm
  // _maxTickSpeed = (int) ((maxRPM * _numTicksPerRevolution) / 60) / (1000 / loopTime); // ticks/loopTime
}

void MotionController::forward(int speed, int distance = 0) {
  _leftMotorDirection = 1;
  _rightMotorDirection = -1;

  // _targetCommand = REQUEST_FORWARD;
  _targetDistance = distance;
  _accTicks = 0;

  _leftMotorController.move(speed, _leftMotorDirection);
  _rightMotorController.move(speed, _rightMotorDirection);
}

/**
 * Reverse
 * @param speed
 * @param distance
 */
void MotionController::reverse(int speed, int distance = 0) {
  _leftMotorDirection = -1;
  _rightMotorDirection = 1;

  // _targetCommand = REQUEST_REVERSE;
  _targetDistance = distance;
  _accTicks = 0;

  _leftMotorController.move(speed, _leftMotorDirection);
  _rightMotorController.move(speed, _rightMotorDirection);
}

/**
 * Rotate
 * @param speed
 * @param angle
 * @param direction
 */
void MotionController::rotate(int speed, int angle, int direction = 0) {
  _leftMotorDirection = direction == 1 ? -1 : 1;
  _rightMotorDirection = direction == 1 ? -1 : 1;

  // _targetCommand = REQUEST_ROTATE;
  _targetDistance = _wheelBaseCircumference / (360 / angle);
  _accTicks = 0;

  // _leftMotorController.move(speed, _leftMotorDirection);
  // _rightMotorController.move(speed, _rightMotorDirection);
}

/**
 * Turn
 * @param speed
 * @param angle
 * @param radius
 * @param direction
 */
void MotionController::turn(int speed, int angle, int radius, int direction = 0) {
  _leftMotorDirection = direction == 1 ? -1 : 1;
  _rightMotorDirection = direction == 1 ? 1 : -1;

  // _targetCommand = REQUEST_TURN;

  int speedLeft = speed; // FIXME calculate left speed based on radius
  int speedRight = speed; // FIXME calculate right speed based on radius

  // _leftMotorController.move(speedLeft, _leftMotorDirection);
  // _rightMotorController.move(speedRight, _rightMotorDirection);
}

/**
 * Drive
 * @param speedLeft
 * @param speedRight
 */
void MotionController::drive(int speedLeft, int speedRight) {
  _leftMotorDirection = 1;
  _rightMotorDirection = -1;

  // _leftMotorController.move(speedLeft, _leftMotorDirection);
  // _rightMotorController.move(speedRight, _rightMotorDirection);
}

/**
 * Stop
 * @param hard
 */
void MotionController::stop(bool hard = false) {
  _leftMotorDirection = 0;
  _rightMotorDirection = 0;

  _leftMotorController.stop(hard);
  _rightMotorController.stop(hard);
}

/**
 * Distance handler
 * @param leftTicks
 * @param rightTicks
 */
// void MotionController::distanceHandler(int leftTicks, int rightTicks) {
//   int numTargetTicks = round(_targetDistance / distancePerTick);
//   _accTicks += (leftTicks + rightTicks) / 2;

//   if (_accTicks >= numTargetTicks) {
//     stop(true);

//     if (_targetCommand != 0) {
//       uint8_t response[4] = {
//         RESPONSE_START_FLAG_1,
//         RESPONSE_START_FLAG_2,
//         _targetCommand,
//         0x00
//       };

//       serial.send(response, sizeof(response));
//     }

//     _targetCommand = 0;
//     _targetDistance = 0;
//   }
// }

/**
 * Left encoder tick event handler
 */
void MotionController::onLeftEncoderTick() {
  _leftMotorController.onEncoderTick();
}

/**
 * Right encoder tick event handler
 */
void MotionController::onRightEncoderTick() {
  _rightMotorController.onEncoderTick();
}

/**
 * Update
 */
void MotionController::update() {
  // byte deltaLeftTicks = _leftMotorController.onTimerInterrupt();
  // byte deltaRightTicks = _rightMotorController.onTimerInterrupt();

  // if (_targetDistance != 0) {
  //   distanceHandler(deltaLeftTicks, deltaRightTicks);
  // }

  // return {
  //   _leftMotorDirection < 0 ? 0 : 1,
  //   deltaLeftTicks,
  //   _rightMotorDirection < 0 ? 1 : 0,
  //   deltaRightTicks,
  // }
}

void MotionController::setup() {
  _leftMotorController.setup(4, 5, 6, 12, MOTOR_LEFT_ENCODER_A_PIN, MOTOR_LEFT_ENCODER_B_PIN);
  _rightMotorController.setup(8, 9, 10, 11, MOTOR_RIGHT_ENCODER_A_PIN, MOTOR_RIGHT_ENCODER_B_PIN);
}

/**
 * Loop
 */
void MotionController::loop() {
  _leftMotorController.loop();
  _rightMotorController.loop();
}
